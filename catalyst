#!/bin/lua

-- 

local system = require("lua.system")
local features = require("lua.feature")
local options = require("lua.options")

-- Exit early if bad script env
if features.error() then
	print(features.error())
	return
end

-- TODO: This should move but I don't know of the best place to put it yet
local function output_Usage()
	print("USAGE: catalyst <mode> [-t system] [-f features] [-d] [-s]")
	for k, v in pairs(options) do
		print("\n     > ", k .. " -- (default: " .. tostring(v.default) .. ")")
		print("", v.desc.summary)
	end
end

-- Exit early if bad script params
if options.__error then
	print(options.__error)
	output_Usage()
	return
end

-- It is necessary to obtain the directory of the repo
local repo_dir = os.getenv("PWD")
assert(repo_dir, "Failed to get repo directory path")

-- TODO: Consider matching os.getenv("HOME") to see if the relative path can be
-- used instead of the absolute (i.e. replace /home/ with ~/)

-- Assert that this is really the right directory
-- TODO: No idea without testing if this works across machines
do
	local git_desc = io.open(repo_dir .. "/.git/description")
	assert(git_desc:read():match("^(catalyst)$"))
	git_desc:close()
end

--

print("└── >>> CATALYST CONFIG HELPER\n")
-- print("───────────────────────────────────")

print("Script options:")
for k, o in pairs(options) do
	local val = options[o]
	if val ~= false then
		val = (type(val) == "string") and val:lower() or val
		k = k:sub(1, 7):upper() -- Prettier formatting
		print(" |    >", k, val)
	end
end
print() -- Useless formatting

-- OPTIONS USAGE NOTE
-- This isn't an perfect design. At first it was a couple different tables;
-- when I merged them, I didn't handle the metatable API very intuitively.
-- Thus, the way to actually get a script argument is options[options.<option>]
-- where <option> refers to the actual name of the option (mode, system, etc.)

local _mode = options.mode
local _feat = options.features
local _system = options.system
local _debug = options.debug
local _script = options.script

if options[_mode] == "USAGE" then
	print("───────────────────────────────────")
	output_Usage()
	return
end

-- A config target should be known for a full check/install
-- Specifying only common config is possible by setting the target to NONE

local system, system_spec = system(options[_system])

-- Current use case means that any other option will at least build a
-- feature list and check the setup of those features

features(options[_feat]) -- Perform the initial list modification (per script argument)
if options[_script] then
	features.print()
	print() -- Useless formatting
else
	-- Prompt user for modifications
	features.interactive()
end

-- 

-- CORE "ACTUALLY DOES THE THING" LOOP
local did_something = false -- Useless output text check
for feat, spec in pairs(features) do
	print("── INSTALLING", feat)
	local feature_dir = repo_dir .. "/" .. feat

	-- NOTE: Not the best place for this, but with regarding to implemeting copy
	-- Uninstall should assume links or sys edits always. The presence of a link
	-- makes cleanup easy. The only use case for copy is a system where I want
	-- to edit the config crazy style anyway.

	-- Copy/link common files (copy is TODO)
	local common_files = spec.location
	if type(common_files) == "string" then
		common_files = { ["."] = common_files }
	end
	if type(common_files) == "table" then
		for file, install_location in pairs(common_files) do
			local link_target = feature_dir .. "/common/" .. file

			-- While this would be a valid path, it means that a string was
			-- empty when it should not have been
			assert(not link_target:match("//"))

			local cmd = string.format("ln -s %s %s", link_target, install_location)
			print(cmd)
		end


	end

	did_something = true
end

if not did_something then
	print("No features were selected :(")
	return
end
