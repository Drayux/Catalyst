#!/bin/lua

-- This is cursed but it (probably) guarantees the correct path--not sure if I want to use it
-- #!/usr/bin/env -S sh -c 'RP="$(realpath "$0")"; cd "$(dirname "$RP")"; exec /bin/lua "$RP"'

-- 

local features = require("lua.feature")
local options = require("lua.options")

-- Exit early if bad script env
if features.error() then
	print(features.error())
	return
end

-- TODO: This should move but I don't know of the best place to put it yet
local function output_Usage()
	print("USAGE: catalyst <mode> [-t system] [-f features] [-d] [-s]")
	for k, v in pairs(options) do
		print("\n     * ", k .. " -- (default: " .. tostring(v.default) .. ")")
		print("", v.desc.summary)
	end
end

-- Exit early if bad script params
if options.__error then
	print(options.__error)
	output_Usage()
	return
end

--

print("└── >>> CATALYST CONFIG HELPER\n")
-- print("───────────────────────────────────")
options:print()

-- OPTIONS USAGE NOTE
-- This isn't an perfect design. At first it was a couple different tables;
-- when I merged them, I didn't handle the metatable API very intuitively.
-- Thus, the way to actually get a script argument is options[options.<option>]
-- where <option> refers to the actual name of the option (mode, system, etc.)

local _mode = options.mode
local _features = options.features
local _system = options.system
local _debug = options.debug
local _script = options.script

-- Check for early-exit modes
if options[_mode] == "USAGE" then
	print("───────────────────────────────────")
	output_Usage()
	return
elseif options[_mode] == "TEST" then
	require("lua.test")
	return
end

-- A config target should be known for a full check/install
-- Specifying only common config is possible by setting the target to NONE
local system_spec = options[_system]

-- Current use case means that any other option will at least build a
-- feature list and check the setup of those features
-- TODO: Move this to option.process (like system; line becomes the following)
-- > local features = options[_features]
features(options[_features]) -- Perform the initial list modification (per script argument)

if options[_script] then
	features.print()
	print() -- Useless formatting
else
	-- Prompt user for modifications
	features.interactive()
end

-- 

-- CORE "ACTUALLY DOES THE THING" LOOP

-- NOTE: Not the best place for this, but with regarding to implementing copy
-- Uninstall should assume links or sys edits always. The presence of a link
-- makes cleanup easy. The only use case for copy is a system where I want
-- to edit the config crazy style anyway.

local did_something = false -- Useless output text check
for feat, spec in pairs(features) do
	print("── INSTALLING", feat)
	local feature_dir = repo_dir .. "/" .. feat

	-- Copy/link common files (copy is TODO)
	local common_files = spec.location
	if type(common_files) == "string" then
		common_files = { ["."] = common_files }
	end
	if type(common_files) == "table" then
		for file, install_location in pairs(common_files) do
			local link_target = feature_dir .. "/common/" .. file

			-- While this would be a valid path, it means that a string was
			-- empty when it should not have been
			assert(not link_target:match("//"))

			local cmd = string.format("ln -s %s %s", link_target, install_location)
			print(cmd)
		end


	end

	did_something = true
end

if not did_something then
	print("No features were selected :(")
	return
end
